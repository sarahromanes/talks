<!DOCTYPE html>
<html>
  <head>
    <title>multiDA and genDA</title>
    <meta charset="utf-8">
    <meta name="author" content="  Sarah Romanes   <span>&lt;i class="fab  fa-twitter faa-float animated "&gt;&lt;/i&gt;&amp;nbsp;@sarah_romanes</span>" />
    <link href="libs/font-awesome-animation/font-awesome-animation-emi.css" rel="stylesheet" />
    <script src="libs/fontawesome/js/fontawesome-all.min.js"></script>
    <link href="libs/font-awesome/css/fontawesome-all.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="assets\kunoichi.css" type="text/css" />
    <link rel="stylesheet" href="assets\ninjutsu.css" type="text/css" />
    <link rel="stylesheet" href="assets\custom.css" type="text/css" />
    <link rel="stylesheet" href="assets\ninpo.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# multiDA and genDA
## Discriminant Analysis Methods for Large Scale and Complex Datasets
### <br><br>Sarah Romanes   <span>&lt;i class="fab  fa-twitter faa-float animated "&gt;&lt;/i&gt;&amp;nbsp;@sarah_romanes</span>
### <br>12-Jul-2019<br><br><span>&lt;i class="fas  fa-link faa-vertical animated " style=" color:white;"&gt;&lt;/i&gt;&amp;nbsp;bit.ly/SR-useR-2019</span>

---







class: split-70 hide-slide-number
background-image: url("bkg/bg2.jpg")
background-size: cover

.column.slide-in-left[
.sliderbox.vmiddle.shade_main.center[
.font5[Discriminant Analysis]]]
.column[
]


---
class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# What is Discriminant Analysis?

&lt;br&gt;

### -  Discriminant Analysis (Fisher, 1936) is a ML technique that seeks to find a linear combination of features that separates classes of objects.
&lt;br&gt;

### -  It *strictly* assumes the conditional distribution of the data, given class grouping, is .orange[multivariate normal].

&lt;br&gt;

### -  Available through `MASS` package in <i class="fab  fa-r-project "></i> with functions `lda` (common covariance) and `qda`. 


]]
.column[.content.vmiddle.center[




&lt;img src="index_files/figure-html/unnamed-chunk-1-1.png" width="504" /&gt;



 

]]


---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# Issues with DA

&lt;br&gt;

## **Does not work in high dimensions**

&lt;br&gt;

## DA does not work when p&gt;n due to a required covariance inverse being singular.

&lt;br&gt;

## .orange[Solution? **multiDA**]

]]
.column.bg-main5[.content[

&lt;br&gt;

&lt;br&gt;

&lt;br&gt;

# .black[**Does not work for non-Gaussian response**]

&lt;br&gt;

## .black[Cannot use for count/ skewed/ binary/ mixed response data, etc.]

&lt;br&gt;

## .orange[Solution? **genDA**]
]]



---


class: split-70 hide-slide-number
background-image: url("bkg/bg2.jpg")
background-size: cover

.column.slide-in-left[
.sliderbox.vmiddle.shade_main.center[
.font5[multiDA]]]
.column[
]
---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# SRBCT data



]]
.column[.content.vmiddle.center[


 &lt;img src="images/SRBCT-nature.jpg", width="70%"&gt;

.purple[Source:] [Nature](https://www.nature.com/articles/modpathol2016119)


]]



---

class: middle center bg-main2

# Pipeline

---

class: split-two white

.column.bg-main2[.content.vmiddle.center[

# So, what makes a discriminative feature?


Suppose we have 3 classes to model. We could group them as 

*One group*... (aka, NOT a discriminative feature)

]]
.column[.content.vmiddle.center[

&lt;img src="index_files/figure-html/unnamed-chunk-2-1.png" width="504" /&gt;


]]


---

class: split-two white

.column.bg-main2[.content.vmiddle.center[

# So, what makes a discriminative feature?

**Two groups** group 1 against 2 and 3


]]
.column[.content.vmiddle.center[


&lt;img src="index_files/figure-html/unnamed-chunk-3-1.png" width="504" /&gt;


]]


---

class: split-two white

.column.bg-main2[.content.vmiddle.center[

# So, what makes a discriminative feature?

**Two groups** group 2 against 1 and 3




]]
.column[.content.vmiddle.center[

&lt;img src="index_files/figure-html/unnamed-chunk-4-1.png" width="504" /&gt;


]]


---

class: split-two white

.column.bg-main2[.content.vmiddle.center[

# So, what makes a discriminative feature?


... and **Two groups** group 3 against 1 and 2

]]
.column[.content.vmiddle.center[

&lt;img src="index_files/figure-html/unnamed-chunk-5-1.png" width="504" /&gt;



]]


---

class: split-two white

.column.bg-main2[.content.vmiddle.center[

# So, what makes a discriminative feature?

... and finally, **three groups** (all are different).


]]
.column[.content.vmiddle.center[

&lt;img src="index_files/figure-html/unnamed-chunk-6-1.png" width="504" /&gt;
]]

---

class: middle center white

# .black[A Penalised LRT is used to determine best fit for each feature]

&lt;img src="images/LRT.png", width="100%"&gt;

---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `multiDA` - syntax

&lt;br&gt;


```r
*res &lt;- multiDA(y = y,
               X = X,
               penalty = "EBIC",
               equal.var = TRUE,
               set.options = "exhaustive")
```


]]
.column.bg-main5[.content.vmiddle.center[



]]

---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `multiDA` - syntax

&lt;br&gt;


```r
res &lt;- multiDA(y = y, 
*              X = X,
               penalty = "EBIC",
               equal.var = TRUE,
               set.options = "exhaustive")
```


]]
.column.bg-main5[.content.vmiddle.center[




]]
---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `multiDA` - syntax

&lt;br&gt;


```r
res &lt;- multiDA(y = y, 
               X = X,
*              penalty = "EBIC",
               equal.var = TRUE,
               set.options = "exhaustive")
```


]]
.column.bg-main5[.content.vmiddle.center[




]]
---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `multiDA` - syntax

&lt;br&gt;


```r
res &lt;- multiDA(y = y, 
               X = X,
               penalty = "EBIC",
*              equal.var = TRUE,
               set.options = "exhaustive")
```


]]
.column.bg-main5[.content.vmiddle.center[




]]

---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `multiDA` - syntax

&lt;br&gt;


```r
res &lt;- multiDA(y = y, 
               X = X,
               penalty = "EBIC",
               equal.var = TRUE,
*              set.options = "exhaustive")
```


]]
.column.bg-main5[.content.vmiddle.center[




]]

---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `multiDA` - syntax

&lt;br&gt;


```r
res &lt;- multiDA(y = y, 
               X = X,
               penalty = "EBIC",
               equal.var = TRUE,
               set.options = "exhaustive") 
```

&lt;br&gt;


```r
*predict(res, newdata = newdata)
```


]]
.column.bg-main5[.content.vmiddle.center[


### A generic S3 `predict` method is used for prediction as follows

]]

---
class: middle center 

# CV results

---

class: split-70 hide-slide-number
background-image: url("bkg/bg2.jpg")
background-size: cover

.column.slide-in-left[
.sliderbox.vmiddle.shade_main.center[
.font5[genDA]]]
.column[
]
---

class: split-two white

.column.bg-main2[.content.vmiddle.center[

# Urban Cover data



]]
.column[.content.vmiddle.center[

&lt;img src="images/urban.jpg", width="80%"&gt;


]]


---

class: split-two white

.column.bg-main2[.content.vmiddle.center[

# Urban Cover data



]]
.column[.content.vmiddle.center[

 &lt;img src="images/covariance.png", width="75%"&gt;


]]

---

class: split-two white

.column.bg-main2[.content.vmiddle.center[

# GLLVM



]]
.column[.content[


```r
# A tibble: 168 x 148
   class    BrdIndx  Area Round Bright Compact ShpIndx Mean_G
   &lt;fct&gt;      &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  
 1 car         1.27    91  0.97   231.    1.39    1.47   208.  
 2 concrete    2.36   241  1.56   216.    2.46    2.51   188.  
 3 concrete    2.12   266  1.47   232.    2.07    2.21   207. 
 4 concrete    2.42   399  1.28   230.    2.49    2.73   205. 
 5 concrete    2.15   944  1.73   193.    2.28    4.1    166. 
 6 tree        3.11   169  1.47   172.    2.49    3.35   240.  
 7 car         1.2     44  0.79   209.    1.14    1.36   181. 
 8 car         1       88  0.22   235.    1.11    1.12   208. 
 9 building    1.59  1737  0.67   220.    1.3     1.64   186. 
10 tree        2.37   153  1.3    120.    2.85    2.59   184.


#"log-normal"        "negative-binomial" "log-normal"        "log-normal"        "log-normal"        "log-normal"        "log-normal"    
```


]]


---

class: split-33 with-thick-border

.column.bg-main2[.content.vmiddle.center[

# GLLVM matrix


]]
.column[.content.vmiddle.center[


 &lt;img src="images/class-1.png", width="80%"&gt;



]]

---
class: split-33 with-thick-border

.column.bg-main2[.content.vmiddle.center[

# GLLVM matrix


]]
.column[.content.vmiddle.center[


 &lt;img src="images/class-2.png", width="80%"&gt;



]]

---

class: split-33 with-thick-border

.column.bg-main2[.content.vmiddle.center[

# GLLVM matrix


]]
.column[.content.vmiddle.center[


 &lt;img src="images/class-3.png", width="80%"&gt;



]]

---

class: split-two white

.column.bg-main2[.content.vmiddle.center[

# TMB package



]]
.column[.content[




]]

---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `genDA` - syntax

&lt;br&gt;


```r
*res &lt;- genDA(Y = Y,
            class = class,
            num.lv = 2,
            family = family,
            common.covariance = TRUE,
            row.eff = FALSE,
            standard.errors = FALSE)
```


]]
.column.bg-main5[.content.vmiddle.center[




]]

---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `genDA` - syntax

&lt;br&gt;


```r
res &lt;- genDA(Y = Y, 
*           class = class,
            num.lv = 2,
            family = family,
            common.covariance = TRUE,
            row.eff = FALSE,
            standard.errors = FALSE)
```


]]
.column.bg-main5[.content.vmiddle.center[




]]

---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `genDA` - syntax

&lt;br&gt;


```r
res &lt;- genDA(Y = Y, 
            class = class,
*           num.lv = 2,
            family = family,
            common.covariance = TRUE,
            row.eff = FALSE,
            standard.errors = FALSE)
```


]]
.column.bg-main5[.content.vmiddle.center[




]]

---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `genDA` - syntax

&lt;br&gt;


```r
res &lt;- genDA(Y = Y, 
            class = class,
            num.lv = 2,
*           family = family,
            common.covariance = TRUE,
            row.eff = FALSE,
            standard.errors = FALSE)
```


]]
.column.bg-main5[.content.vmiddle.center[




]]

---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `genDA` - syntax

&lt;br&gt;


```r
res &lt;- genDA(Y = Y, 
            class = class,
            num.lv = 2,
            family = family,
*           common.covariance = TRUE,
            row.eff = FALSE,
            standard.errors = FALSE)
```


]]
.column.bg-main5[.content.vmiddle.center[




]]

---
class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `genDA` - syntax

&lt;br&gt;


```r
res &lt;- genDA(Y = Y, 
            class = class,
            num.lv = 2,
            family = family,
            common.covariance = TRUE,
*           row.eff = FALSE,
            standard.errors = FALSE)
```


]]
.column.bg-main5[.content.vmiddle.center[




]]

---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `genDA` - syntax

&lt;br&gt;


```r
res &lt;- genDA(Y = Y, 
            class = class,
            num.lv = 2,
            family = family,
            common.covariance = TRUE,
            row.eff = FALSE,
*           standard.errors = FALSE)
```


]]
.column.bg-main5[.content.vmiddle.center[




]]

---

class: split-two white

.column.bg-main2[.content[

&lt;br&gt;

# `genDA` - syntax

&lt;br&gt;


```r
res &lt;- genDA(Y = Y, 
            class = class,
            num.lv = 2,
            family = family,
            common.covariance = TRUE,
            row.eff = FALSE,
            standard.errors = FALSE) 
```


&lt;br&gt;


```r
*predict(res, newdata = newdata)
```


]]
.column.bg-main5[.content.vmiddle.center[


### A generic S3 `predict` method is used for prediction as follows

]]

---

class: middle center white

# .black[100 Trial, 5 Fold CV]

&lt;img src="index_files/figure-html/unnamed-chunk-24-1.png" width="864" /&gt;



---
class: split-three white


.column.bg-main3[.content.center[

&lt;br&gt;

&lt;br&gt;

&lt;br&gt;

&lt;img src="images/profile.png", width="65%"&gt;

### <i class="fab  fa-twitter "></i> : sarah_romanes
### <i class="fas  fa-globe "></i> : sarahromanes.github.io

]]

.column.bg-main2[.content.center[

&lt;br&gt;

# genDA

&lt;br&gt;

&lt;img src="images/genDA_logo.png", width="50%"&gt;

## .white[<span>&lt;i class="fab  fa-github faa-float animated "&gt;&lt;/i&gt;</span>]

### [sarahromanes/genDA](https://github.com/sarahromanes/genDA)


]]

.column.bg-main5[.content.center[

&lt;br&gt;

# .black[multiDA]

&lt;br&gt;

&lt;img src="images/multiDA_logo.png", width="50%"&gt;

## .black[<span>&lt;i class="fab  fa-github faa-float animated "&gt;&lt;/i&gt;</span>]

### [sarahromanes/multiDA](https://github.com/sarahromanes/multiDA)

]]
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
